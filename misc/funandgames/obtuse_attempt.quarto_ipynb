{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Obtuse Units\n",
        "execute:\n",
        "    echo: true\n",
        "website:\n",
        "    page-navigation:\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "Tired of using simple, pedestrian units like \"feet\" or \"hours\"? Do you yearn to be technically accurate yet utterly intractable? Want to speak in a way that says \"Wow, now *this* guy is a tool\"? Just use this handy generator to convert any statement into a pointlessly convoluted (yet correct) combination of SI units.\n",
        "\n",
        "This project used to be a Twitter bot, back when Twitter was just incidentally the worst thing to happen to human communication and not intentionally the worst thing to happen to human communication. Mercifully, I put the bot on sleep the moment it was born and tested; now you can use the program for yourself.\n",
        "\n",
        "\n",
        "<!---   Imports    --->\n"
      ],
      "id": "cf33f85c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#Builtin\n",
        "import numpy as np\n",
        "import random\n",
        "import re\n",
        "import time\n",
        "#Extenals\n",
        "from quantulum3 import parser\n",
        "from pint import UnitRegistry"
      ],
      "id": "1aec5989",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<!---   User Input  --->\n",
        "\n",
        "<!---   Config  --->\n"
      ],
      "id": "28473df3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#List of SI derived unit to be used.\n",
        "#(Unit name, Unit dimesions [M,L,T,A], Unit count [0 for no bias])\n",
        "derived_units = np.array([('hertz',   ( 0, 0,-1, 0) ,0),\n",
        "                          ('newton',  ( 1, 1,-2, 0) ,0),\n",
        "                          ('pascal',  ( 1,-1,-2, 0) ,0),\n",
        "                          ('joule',   ( 1, 2,-2, 0) ,0),\n",
        "                          ('watt',    ( 1, 2,-3, 0) ,0),\n",
        "                          ('coulomb', ( 0, 0, 1, 1) ,0),\n",
        "                          ('volt',    ( 1, 2,-3,-1) ,0),\n",
        "                          ('farad',   (-1,-2, 4, 2) ,0),\n",
        "                          ('ohm',     ( 1, 2,-3,-2), 0),\n",
        "                          ('siemen',  (-1,-2, 3, 2), 0),\n",
        "                          ('weber',   ( 1, 2,-2,-1), 0),\n",
        "                          ('tesla',   ( 1, 0,-2,-1), 0),\n",
        "                          ('henry',   ( 1, 2,-2,-2), 0),\n",
        "                          ('sievert', ( 0, 2,-2, 0), 0)],\n",
        "                          dtype=[('uname','U10'), ('dims',np.ndarray),('count',np.float32)])\n",
        "\n",
        "#List of SI prefixes and their associated powers\n",
        "#Removing prefixes in the range (-1,1) may cause basis spanning issues in calls with very tight user tolerances.\n",
        "prefixes = np.array([('yotta', 24),\n",
        "                     ('zetta', 21),\n",
        "                     ('exa',   18),\n",
        "                     ('peta',  15),\n",
        "                     ('tera',  12),\n",
        "                     ('giga',   9),\n",
        "                     ('mega',   6),\n",
        "                     ('kilo',   3),\n",
        "                     ('hecto',  2),\n",
        "                     ('deca',   1),\n",
        "                     ('',       0),\n",
        "                     ('deci',  -1),\n",
        "                     ('centi', -2),\n",
        "                     ('milli', -3),\n",
        "                     ('micro', -6),\n",
        "                     ('nano',  -9),\n",
        "                     ('pico', -12),\n",
        "                     ('femto',-15),\n",
        "                     ('atto', -18),\n",
        "                     ('zepto',-21),\n",
        "                     ('yocto',-24)],\n",
        "                     dtype=[('name','U10'), ('mag',np.int8)])"
      ],
      "id": "3f26879f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<!---   Core conversion function    --->\n"
      ],
      "id": "e1bcce01"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def obtusify(val, idims, SI, pref, loops = 2, maxvalord = None, minvalord = None, maxprefs = None, spread = None):\n",
        "    '''\n",
        "    Given a quantity in SI base units, returns an equivalent value in an obtuse combination of\n",
        "      derived SI units and prefixes\n",
        "\n",
        "    Args:\n",
        "      val   -- float : numerical value of quantity in base units\n",
        "      idims -- (4,) : tuple corresponding to dimensionality of input quantity (M,L,T,I)\n",
        "      SI    -- (n,5) struct ndarray : information on SI derived units, see config\n",
        "      pref  -- (n,2) struct ndarray : indicating a set of SI prefixes to superfluously add\n",
        "\n",
        "    Kwargs:\n",
        "      loops       -- int : Number of derived units to be present in the obfuscation. Set it irresponsibly high!\n",
        "      maxvalord   -- int : If not None, maximum order of output numeric value\n",
        "      minvalord   -- int : If not None, minimum order of output numeric value\n",
        "      maxprefs    -- int : If not None, maximum number of SI prefixes to include in output\n",
        "      spread      -- float [0,1) : If not None, creates a bias towards including more individual unit names\n",
        "                       in the output (vs. less unique names with higher powers). Strong interaction with loops.\n",
        "\n",
        "    Returns:\n",
        "      ostring -- string : quantity equal to input, expressed obtusely\n",
        "\n",
        "    Sample Usage:\n",
        "        # Obtusification of 8024 metres\n",
        "        obtusify(8024, (0,1,0,0), config.SI, config.pref) --> \"8.024 microsievert-kilograms per nanonewton\"\n",
        "    '''\n",
        "\n",
        "    #Basic input checks\n",
        "    if maxvalord == None: maxvalord =  np.inf\n",
        "    if minvalord == None: minvalord = -np.inf\n",
        "    if maxvalord - minvalord < 0:\n",
        "        print(\"You set the output value order minimum higher than the maximum. Don't think I don't see you trying to crash the prefix algorithm.\")\n",
        "        raise Exception\n",
        "\n",
        "    #Pick a random non-zero positive dimension\n",
        "    ind = random.choice([i for i,x in enumerate(idims) if x > 0])\n",
        "\n",
        "    #Pick a random SI derived unit which is nonzero positive in this dimension (ensures at least one unit on numerator)\n",
        "    SIind = random.choice([i for i,x in enumerate(SI['dims']) if x[ind] > 0])\n",
        "    SI['count'][SIind] += 1\n",
        "\n",
        "    #Check which dimensions remain to be filled\n",
        "    wSI = [np.array(x)*y for x,y in zip(SI['dims'], SI['count'])]\n",
        "    remainder = idims - np.sum(wSI, axis=0)\n",
        "\n",
        "\n",
        "    #Loop while dimensions are not matched\n",
        "    i = 0\n",
        "    while i < loops:\n",
        "        i += 1\n",
        "\n",
        "        #Find the derived unit which would most decrease the remainder if added to the numerator\n",
        "        diffs = np.sum(np.abs([list(x) - remainder for x in SI['dims']]), axis=1).astype(np.float32)\n",
        "        diffs[SI['count'] < 0] = np.nan #Ignore options which would simply cancel out existing units\n",
        "        n,ndiff = np.where(diffs == np.nanmin(diffs))[0][0], np.nanmin(diffs)\n",
        "        #Find the derived unit which would most decrease the remainder if added to the denominator\n",
        "        diffs = np.sum(np.abs([list(x) + remainder for x in SI['dims']]), axis=1).astype(np.float32)\n",
        "        diffs[SI['count'] > 0] = np.nan\n",
        "        d,ddiff = np.where(diffs == np.nanmin(diffs))[0][0], np.nanmin(diffs) #when added to the denominator\n",
        "\n",
        "        #Sometimes selecting the unit which best moves the dimensionality towards the target actually produces\n",
        "        #  lackluster results, e.g. feedback loops of two units undoing eachother around the target.\n",
        "        #These options are ways to introduce bias for more interesting results\n",
        "        if spread is not None and loops - i > 3:\n",
        "            #Adds a chance to instead select a random unused unit if possible\n",
        "            if np.random.rand() > spread and 0 in SI['count']:\n",
        "                uu = random.choice([i for i,x in enumerate(SI['count']) if x == 0])\n",
        "                if np.random.rand() > .5:\n",
        "                    SI['count'][uu] += 1 #Slap it on the numerator\n",
        "                else:\n",
        "                    SI['count'][uu] -= 1 #Slap it on the denominator\n",
        "        else:\n",
        "            if ndiff <= ddiff:\n",
        "                SI['count'][n] += 1\n",
        "            else:\n",
        "                SI['count'][d] -= 1\n",
        "\n",
        "        #Check which dimensions remain to be filled\n",
        "        wSI = [np.array(x)*y for x,y in zip(SI['dims'], SI['count'])]\n",
        "        remainder = idims - np.sum(wSI, axis=0)\n",
        "\n",
        "    #Assign SI prefixes\n",
        "    nslots = np.sum(SI['count'] > 0) + np.sum(remainder > 0) #Number of slots available on numerator\n",
        "    dslots = np.sum(SI['count'] < 0) + np.sum(remainder < 0) #Number of slots available on denominator\n",
        "    pn = np.full(nslots, None)\n",
        "    pd = np.full(dslots, None)\n",
        "\n",
        "    #Bound the number of prefixes to be added\n",
        "    if maxprefs is not None:\n",
        "        nempty, dempty = np.sum(pn == None), np.sum(pd == None)\n",
        "        while nempty + dempty > maxprefs:\n",
        "            #Fill a random slot with an empty prefix (uniform selection across all slots)\n",
        "            ratio = nempty/(nempty + dempty)\n",
        "            if np.random.rand() < ratio:\n",
        "                i = [i for i,x in enumerate(pn) if x == None]\n",
        "                pn[random.choice(i)] = 0\n",
        "            else:\n",
        "                i = [i for i,x in enumerate(pd) if x == None]\n",
        "                pd[random.choice(i)] = 0\n",
        "            nempty, dempty = np.sum(pn == None), np.sum(pd == None)\n",
        "\n",
        "    #Assign arbitrary prefixes to open slots slots, avoiding dupes\n",
        "    for i in [i for i,x in enumerate(pn) if x == None]:\n",
        "        pn[i] = random.choice(pref['mag'])\n",
        "    for i in [i for i,x in enumerate(pd) if x == None]:\n",
        "        pd[i] = random.choice(pref['mag'])\n",
        "\n",
        "    #Unit exponents (and thus prefix powers)\n",
        "    en =  [ i for i in SI['count'][SI['count'] > 0]] #Derived units\n",
        "    en += [ i for i in remainder if i > 0]           #Base units\n",
        "    ed =  [-i for i in SI['count'][SI['count'] < 0]] #Derived units\n",
        "    ed += [-i for i in remainder if i < 0]           #Base units\n",
        "\n",
        "    #Lower/raise prefixes until within user tolerance\n",
        "    current_ord = sum([p*e for p,e in zip(pn,en)]) - sum([p*e for p,e in zip(pd,ed)]) - np.floor(np.log10(val))\n",
        "    ratio = len(pn)/ (len(pn) + len(pd))\n",
        "    numprobs = [e if p!=0 else 0 for e,p in zip(en,pn)] #Favour modifying high power values (no one wnats to see \"yoctometres octed\" (I kinda do though))\n",
        "    numprobs = np.array(numprobs)/np.sum(np.abs(numprobs)) #  Additionally, don't select empty prefixes for change to prevent conflict with maxprefs\n",
        "    denprobs = [e if p!=0 else 0 for e,p in zip(ed,pd)] #Favour modifying high power values (no one wnats to see \"yoctometres octed\" (I kinda do though))\n",
        "    denprobs = np.array(denprobs)/np.sum(np.abs(denprobs)) #  Additionally, don't select empty prefixes for change to prevent conflict with maxprefs\n",
        "    t = 0\n",
        "    while current_ord > maxvalord or current_ord < minvalord:\n",
        "        t+=1\n",
        "        if t>100:\n",
        "            print(\"Error, unable to meet user tolerance for output value magnitude within %i iteration attempts\"%t)\n",
        "            print(\"Keywords minvalord/maxvalord most likely define an extremely narrow range\")\n",
        "            raise Exception()\n",
        "        if current_ord > maxvalord:\n",
        "            if np.random.rand() < ratio:\n",
        "                #Go down one prefix in a numerator slot\n",
        "                i = np.random.choice(range(len(pn)), p=numprobs)\n",
        "                newprefs = pref['mag'][pref['mag'] < pn[i]]\n",
        "                if len(newprefs) == 0: continue #If there is no such prefix, reiterate\n",
        "                pn[i] = min(newprefs, key=lambda x:abs(x-pn[i]))\n",
        "            else:\n",
        "                #Go up on prefix in a denominator slot\n",
        "                i = np.random.choice(range(len(pd)), p=denprobs)\n",
        "                newprefs = pref['mag'][pref['mag'] > pd[i]]\n",
        "                if len(newprefs) == 0: continue\n",
        "                pd[i] = min(newprefs, key=lambda x:abs(x-pd[i]))\n",
        "        else:\n",
        "            if np.random.rand() < ratio:\n",
        "                #Go up one prefix in a numerator slot\n",
        "                i = np.random.choice(range(len(pn)), p=numprobs)\n",
        "                newprefs = pref['mag'][pref['mag'] > pn[i]]\n",
        "                if len(newprefs) == 0: continue\n",
        "                pn[i] = min(newprefs, key=lambda x:abs(x-pn[i]))\n",
        "            else:\n",
        "                #Go down on prefix in a denominator slot\n",
        "                i = np.random.choice(range(len(pd)), p=denprobs)\n",
        "                newprefs = pref['mag'][pref['mag'] < pd[i]]\n",
        "                if len(newprefs) == 0: continue\n",
        "                pd[i] = min(newprefs, key=lambda x:abs(x-pd[i]))\n",
        "        current_ord = sum([p*e for p,e in zip(pn,en)]) - sum([p*e for p,e in zip(pd,ed)]) - np.floor(np.log10(val))\n",
        "\n",
        "    #Calculate new numerical value of quantity\n",
        "    oval = val / (10**np.floor(np.log10(val))) * 10**-current_ord\n",
        "\n",
        "    #Convert numerical prefix orders to their corresponding strings\n",
        "    pn = [pref['name'][pref['mag'] == i][0] for i in pn]\n",
        "    pd = [pref['name'][pref['mag'] == i][0] for i in pd]\n",
        "    if len(pd) > 0: pd[0] = ' per ' + pd[0]\n",
        "\n",
        "\n",
        "    #Convert exponent values to their corresponding strings\n",
        "    enames = {1:'', 2:'s-squared', 3:'s-cubed', 4:'s-quarted', 5: 's-quinted', 6: 's-sexted', 7: 's-hepted', 8: 's-octed',\n",
        "              9: 'nonned????', 10: 'dude', 11: 'stop', 12: 'the', 13 : 'words', 14: ' don\\'t', 15: 'even', 16: 'go', 17: 'this', 18:'high'} #If you get a key error on this you requested a BEEG obfuscation\n",
        "    en = [enames[i] for i in en]\n",
        "    ed = [enames[i] for i in ed]\n",
        "\n",
        "    #Unit strings\n",
        "    bnames = {0:'kilogram', 1: 'metre', 2: 'second', 3: 'ampere'}\n",
        "    un =  list(SI['uname'][SI['count'] > 0])                     #Derived units\n",
        "    un += [bnames[i] for i,x in enumerate(remainder) if x > 0]   #Base units\n",
        "    ud =  list(SI['uname'][SI['count'] < 0])\n",
        "    ud += [bnames[i] for i,x in enumerate(remainder) if x < 0]\n",
        "\n",
        "    #Construct final value string\n",
        "    ustring = ''\n",
        "    for p,u,e in zip(pn, un, en):\n",
        "        ustring += '-%s%s%s'%(p,u,e)\n",
        "    ustring += 's' #Pluralize\n",
        "    for p,u,e in zip(pd, ud, ed):\n",
        "        ustring += '%s%s%s-'%(p,u,e)\n",
        "    ustring = ustring[1:] #Chop off superfluous hyphens\n",
        "    if len(pd) != 0:\n",
        "        ustring = ustring[:-1]\n",
        "\n",
        "    #Round oval for readability\n",
        "    oval  = np.format_float_positional(oval, precision=4, unique=False, fractional=False, trim='k')\n",
        "    ostring = str(oval) + ' ' + ustring\n",
        "\n",
        "    #Cleanup plurals\n",
        "    ostring = ostring.replace('hertzs', 'hertz')\n",
        "    ostring = ostring.replace('henrys', 'henries')\n",
        "\n",
        "    return ostring"
      ],
      "id": "61610438",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#Python web interactivity\n",
        "from shiny import render\n",
        "from shiny.express import input, ui\n",
        "\n",
        "ui.input_text(\"user_input\", \"uit\", \"I just went on a 3 mile hikeðŸ’ª\")\n",
        "\n",
        "@render.text\n",
        "def value():\n",
        "\n",
        "    ureg = UnitRegistry()\n",
        "\n",
        "    quantunit = parser.parse(input.user_input())[0]\n",
        "    value = quantunit.value\n",
        "    unit  = quantunit.unit.name\n",
        "\n",
        "    #Convert to base SI units\n",
        "    pintunit = value * ureg.parse_expression(unit)\n",
        "    dims = [pintunit.dimensionality.get(name) for name in ['[mass]','[length]','[time]','[current]']]\n",
        "    #Define and convert to a unit in terms of base SI units\n",
        "    bu = ['kilogram','meter','second','ampere']\n",
        "    baseunit = ''\n",
        "    for i,u in zip(dims,bu):\n",
        "        if i !=0:\n",
        "            baseunit = baseunit + u + '**' + str(i) + '*'\n",
        "\n",
        "    ureg.define('base_unit = ' + baseunit[:-1] + '= bu')\n",
        "    pintunit.ito('bu')\n",
        "\n",
        "    #Obtusify the unit\n",
        "    obtuse_quant = obtusify(pintunit.magnitude, dims, derived_units, prefixes, minvalord=-8, maxvalord=8)\n",
        "\n",
        "    obtusified_input = re.sub(quantunit.surface, obtuse_quant, input.user_input())\n",
        "    return obtusified_input"
      ],
      "id": "6853fae2",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "conda-root-py",
      "language": "python",
      "display_name": "Python [conda env:root] *",
      "path": "/home/jake/.local/share/jupyter/kernels/conda-root-py"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}