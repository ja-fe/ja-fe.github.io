---
title: Sums of Waves
execute:
    echo: false
website:
    page-navigation: true
---
## What is Coherence? What is Polarization State?

In reality, most EMR is not "perfectly polarized". EMR can often be viewed as sums of waves with different frequencies. Try adding two different waves together to make strange new waveforms: [about](about.qmd)

```{ojs}
//TODO: This use of html tags to decrease font size to get around label wrapping is bad, find more elegant solution later
viewof form_m1_1 = Inputs.form(
    [
        Inputs.range([1, 30], {label: html`<font size="3.5">Amplitude 1</font>`, step: 1, value: 15}),
        Inputs.range([1, 100], {label: html`<font size="3.5">Wavelength 1</font>`, step: 1, value: 50})
    ],
    {
        template: (inputs) => htl.html`<div style="display: flex; gap: 1em">
        ${inputs}
        </div>`
    }
)
amplitudeW1  = form_m1_1[0];
wavelengthW1 = form_m1_1[1];

viewof form_m1_2 = Inputs.form(
    [
        Inputs.range([1, 30], {label: html`<font size="3.5">Amplitude 2</font>`, step: 1, value: 15}),
        Inputs.range([1, 100], {label: html`<font size="3.5">Wavelength 2</font>`, step: 1, value: 50})
    ],
    {
        template: (inputs) => htl.html`<div style="display: flex; gap: 1em">
        ${inputs}
        </div>`
    }
)

amplitudeW2  = form_m1_2[0];
wavelengthW2 = form_m1_2[1];

viewof form_m1_3 = Inputs.form(
    [
        Inputs.range([0, 6.2], {label: html`<font size="3.5">Phase Diff</font>`, step: 0.1, value: 0}),
        Inputs.range([1, 20], {label: html`<font size="3.5">Speed</font>`, step: 1, value: 10})
    ],
    {
        template: (inputs) => htl.html`<div style="display: flex; gap: 1em">
        ${inputs}
        </div>`
    }
)

phase_diff_m1  = form_m1_3[0];
speed_m1 = form_m1_3[1];


distance = 400;
NumPoints = 1000;
```

```{ojs}
wave1_m1 = {
    var data = [];
    for (var i = 1; i <= NumPoints; i++) {
        var j = i * distance / NumPoints;
        data.push([j , amplitudeW1 * Math.sin(j * 2*Math.PI / wavelengthW1 + time)]);
    }
    return data;
}
```

```{ojs}
wave2_m1 = {
    var data = [];
    for (var i = 1; i <= NumPoints; i++) {
        var j = i * distance / NumPoints;
        data.push([j , amplitudeW2 * Math.sin(j * 2*Math.PI / wavelengthW2 + time + phase_diff_m1)]);
    }
    return data;
}
```

```{ojs}
waveSum_m1 = {
    var data = [];
    for (var i = 1; i <= NumPoints; i++) {
        var j = i * distance / NumPoints;
        data.push([j , amplitudeW1 * Math.sin(j * 2*Math.PI / wavelengthW1 + time) + amplitudeW2 * Math.sin(j * 2*Math.PI / wavelengthW2 + time + phase_diff_m1)]);
    }
    return data;
}
```

```{ojs}
time = {
  let i = 0;
  while (true) {
    i += speed_m1 * 0.01;
    yield i
  }
}
```

```{ojs}
r = d3.line()(wave1_m1);
b = d3.line()(wave2_m1);
svg`<svg viewBox="0 -32 400 64">
  <path d="${r}" stroke="red" fill="none" />
  <path d="${b}" stroke="blue" fill="none" />
</svg>`
```

```{ojs}
p = d3.line()(waveSum_m1);
svg`<svg viewBox="0 -64 400 130">
  <path d="${p}" stroke="black" fill="none" />
</svg>`
```

