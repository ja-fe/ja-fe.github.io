[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "jf_web",
    "section": "",
    "text": "Hi! I am still being built! Check out the incomplete notes below and check back in later -jf"
  },
  {
    "objectID": "index.html#plotly-experimentation",
    "href": "index.html#plotly-experimentation",
    "title": "jf_web",
    "section": "",
    "text": "I am under constuction – please check back later!\n\n\nCode\nviewof amplitudeW1 = Inputs.range([1, 100], {label: \"Amplitude W1\", step: 1});\nviewof periodW1 = Inputs.range([1, 100], {label: \"Period W1\", step: 1});\n\nviewof amplitudeW2 = Inputs.range([1, 100], {label: \"Amplitude W2\", step: 1});\nviewof periodW2 = Inputs.range([1, 100], {label: \"Period W2\", step: 1});\n\nviewof speed = Inputs.range([1, 20], {label: \"Speed\", step: 1});\n\ndistance = 400;\nNumPoints = 1000;\nxfactor = 10;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndata = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitudeW1 * Math.sin(j * 2*Math.PI / periodW1 + time) + amplitudeW2 * Math.sin(j * 2*Math.PI / periodW2 + time)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\ntime = {\n  let i = 0;\n  while (true) {\n    i += speed * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\np = d3.line()(data);\nsvg`&lt;svg viewBox=\"0 -100 400 200\"&gt;\n  &lt;path d=\"${p}\" stroke=\"black\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.io as pio\n\n#-------------Base parameters\n\n#Define curve parameters\nperiod    = 25\nn_samples = 100\nsim_duration  = period*10\namp = 3\nx = np.arange(n_samples)*np.pi/period\n\n#Animation parameters\nframe_duration = 15 #milliseconds?\n\n#Define some groups of parameters here as dictionaries\n#  This greatly clarifies later code\n#  plotly takes arguments which are lists of dicts of lists of dicts... confusing\ndef frame_arguments(duration):\n    return {\n        \"frame\": {\"duration\": duration},\n        \"mode\": \"immediate\",\n        \"redraw\": True,\n        \"fromcurrent\": True,\n        \"transition\": {\"duration\": duration, \"easing\": \"linear\"},\n        \"uirevision\": True\n    }\n\n#--------------Meat and potatoes\n\n#Create figure object containing one trace of the desired graph type\nfig = go.Figure(\n        data=[go.Scatter3d(\n            x = x,\n            y = amp*np.sin(x),\n            z = x,\n            mode = \"lines\",\n            name = \"SineTest\")])\n\n\n#Define the layout of that figure (size, axes ranges, etc.)\nfig.update_layout(\n    template = \"plotly_white\",\n    scene = dict(\n            xaxis=dict(range=[0,5*np.pi], autorange=False),\n            yaxis=dict(range=[-3,3], autorange=False),\n            zaxis=dict(range=[0,5*np.pi], autorange=False)))\n\n#Now customize -- set the background to transparent to pair with theme\nfig.update_layout(plot_bgcolor='rgba(0, 0, 0, 0)',paper_bgcolor='rgba(0, 0, 0, 0)')\n\n\n#Define all frames within the animation\nframes =  [go.Frame(data=[go.Scatter3d(\n                            x=x,\n                            y=amp*np.sin(x+t*np.pi/period),\n                            z=x)],\n                    traces=[0],\n                    name=f\"frame_{t}\")\n                    for t in range(1, sim_duration)]\n\n#Assign said frames to the figure\nfig.update(frames=frames)\n\n#Define the protocols for updating the figure\n#  Here, a button which causes the figure to loop linearly through the frame\nfig.update_layout(\n    updatemenus = [\n        {\n            \"buttons\": [\n                {\n                    \"label\" : \"Play\",\n                    \"method\" : \"animate\", #Affects animation\n                    \"args\" : [None, frame_arguments(frame_duration)]\n                },\n                {\n                    \"label\" : \"Pause\",\n                    \"method\" : \"animate\",\n                    #To FutureJake: This is jank you can't just make a pause button by setting the frame duration to ten billion seconds [FIX]\n                    #  To PastJake: Who's going to stop me?\n                    \"args\" : [None, frame_arguments(1000000000)]\n                }\n            ],\n            #Position/display arguments for the buttons\n            \"y\" : 0.5,\n            \"yanchor\" : \"bottom\",\n            \"xanchor\" : \"center\",\n            \"type\" : \"buttons\"\n        },\n        {\n            \"buttons\": [\n                {\n                    \"label\" : \"Lightmode\",\n                    \"method\" : \"relayout\", #Affects layout attributes\n                    \"args\" : [\"template\", pio.templates[\"plotly_white\"]]\n                },\n                {\n                    \"label\" : \"Darkmode\",\n                    \"method\" : \"relayout\", #Affects layout attributes\n                    \"args\" : [\"template\", pio.templates[\"plotly_dark\"]]\n                }\n            ],\n            \"y\" : 0.4,\n            \"yanchor\" : \"top\",\n            \"xanchor\" : \"center\",\n            \"direction\" : \"down\",\n            \"type\" : \"dropdown\"\n        }\n    ]\n)        \n\n#Finally, render the figure\nfig.show()\n\n\n\n                                                \n\n\n\n\nCode\n'''\nimport numpy as np\nimport plotly.graph_objects as go\nimport plotly.io as pio\n\n#-------------Base parameters\n\n#Define curve parameters\nperiod    = 50\nn_samples = 100\nsim_duration  = period*10\namp = 6\nx = np.arange(n_samples)*np.pi/period*3\n\n#Animation parameters\nframe_duration = 25 #milliseconds?\n\n#Define some groups of parameters here as dictionaries\n#  This greatly clarifies later code\n#  plotly takes arguments which are lists of dicts of lists of dicts... confusing\ndef frame_arguments(duration):\n    return {\n        \"frame\": {\"duration\": duration},\n        \"mode\": \"immediate\",\n        \"redraw\": True,\n        \"fromcurrent\": True,\n        \"transition\": {\"duration\": duration, \"easing\": \"linear\"},\n        \"uirevision\": True\n    }\n\n#--------------Meat and potatoes\n\n#Create figure object containing one trace of the desired graph type\nfig = go.Figure(\n        data=[go.Scatter3d(\n            x = amp*np.sin(x+np.pi/2),\n            y = amp*np.sin(x),\n            z = x,\n            mode = \"lines\",\n            name = \"SineTest\")])\n\n\n#Define the layout of that figure (size, axes ranges, etc.)\nfig.update_layout(\n    template = \"plotly_white\",\n    scene = dict(\n            xaxis=dict(range=[-10,10], autorange=False),\n            yaxis=dict(range=[-10,10], autorange=False),\n            zaxis=dict(range=[0,10], autorange=False)))\n\n#Now customize -- set the background to transparent to pair with theme\nfig.update_layout(plot_bgcolor='rgba(0, 0, 0, 0)',paper_bgcolor='rgba(0, 0, 0, 0)')\n\n\n#Define all frames within the animation\nframes =  [go.Frame(data=[go.Scatter3d(\n                            x=amp*np.sin(x+t*np.pi/period+np.pi/2),\n                            y=amp*np.sin(x+t*np.pi/period),\n                            z=x)],\n                    traces=[0],\n                    name=f\"frame_{t}\")\n                    for t in range(1, sim_duration)]\n\n#Assign said frames to the figure\nfig.update(frames=frames)\n\n#Define the protocols for updating the figure\n#  Here, a button which causes the figure to loop linearly through the frame\nfig.update_layout(\n    updatemenus = [\n        {\n            \"buttons\": [\n                {\n                    \"label\" : \"Play\",\n                    \"method\" : \"animate\", #Affects animation\n                    \"args\" : [None, frame_arguments(frame_duration)]\n                },\n                {\n                    \"label\" : \"Pause\",\n                    \"method\" : \"animate\",\n                    #To FutureJake: This is jank you can't just make a pause button by setting the frame duration to ten billion seconds [FIX]\n                    #  To PastJake: Who's going to stop me?\n                    \"args\" : [None, frame_arguments(1000000000)]\n                }\n            ],\n            #Position/display arguments for the buttons\n            \"y\" : 0.5,\n            \"yanchor\" : \"bottom\",\n            \"xanchor\" : \"center\",\n            \"type\" : \"buttons\"\n        },\n        {\n            \"buttons\": [\n                {\n                    \"label\" : \"Lightmode\",\n                    \"method\" : \"relayout\", #Affects layout attributes\n                    \"args\" : [\"template\", pio.templates[\"plotly_white\"]]\n                },\n                {\n                    \"label\" : \"Darkmode\",\n                    \"method\" : \"relayout\", #Affects layout attributes\n                    \"args\" : [\"template\", pio.templates[\"plotly_dark\"]]\n                }\n            ],\n            \"y\" : 0.4,\n            \"yanchor\" : \"top\",\n            \"xanchor\" : \"center\",\n            \"direction\" : \"down\",\n            \"type\" : \"dropdown\"\n        }\n    ]\n)        \n\n#Finally, render the figure\nfig.show()\n'''\n\n\n'\\nimport numpy as np\\nimport plotly.graph_objects as go\\nimport plotly.io as pio\\n\\n#-------------Base parameters\\n\\n#Define curve parameters\\nperiod    = 50\\nn_samples = 100\\nsim_duration  = period*10\\namp = 6\\nx = np.arange(n_samples)*np.pi/period*3\\n\\n#Animation parameters\\nframe_duration = 25 #milliseconds?\\n\\n#Define some groups of parameters here as dictionaries\\n#  This greatly clarifies later code\\n#  plotly takes arguments which are lists of dicts of lists of dicts... confusing\\ndef frame_arguments(duration):\\n    return {\\n        \"frame\": {\"duration\": duration},\\n        \"mode\": \"immediate\",\\n        \"redraw\": True,\\n        \"fromcurrent\": True,\\n        \"transition\": {\"duration\": duration, \"easing\": \"linear\"},\\n        \"uirevision\": True\\n    }\\n\\n#--------------Meat and potatoes\\n\\n#Create figure object containing one trace of the desired graph type\\nfig = go.Figure(\\n        data=[go.Scatter3d(\\n            x = amp*np.sin(x+np.pi/2),\\n            y = amp*np.sin(x),\\n            z = x,\\n            mode = \"lines\",\\n            name = \"SineTest\")])\\n\\n\\n#Define the layout of that figure (size, axes ranges, etc.)\\nfig.update_layout(\\n    template = \"plotly_white\",\\n    scene = dict(\\n            xaxis=dict(range=[-10,10], autorange=False),\\n            yaxis=dict(range=[-10,10], autorange=False),\\n            zaxis=dict(range=[0,10], autorange=False)))\\n\\n#Now customize -- set the background to transparent to pair with theme\\nfig.update_layout(plot_bgcolor=\\'rgba(0, 0, 0, 0)\\',paper_bgcolor=\\'rgba(0, 0, 0, 0)\\')\\n\\n\\n#Define all frames within the animation\\nframes =  [go.Frame(data=[go.Scatter3d(\\n                            x=amp*np.sin(x+t*np.pi/period+np.pi/2),\\n                            y=amp*np.sin(x+t*np.pi/period),\\n                            z=x)],\\n                    traces=[0],\\n                    name=f\"frame_{t}\")\\n                    for t in range(1, sim_duration)]\\n\\n#Assign said frames to the figure\\nfig.update(frames=frames)\\n\\n#Define the protocols for updating the figure\\n#  Here, a button which causes the figure to loop linearly through the frame\\nfig.update_layout(\\n    updatemenus = [\\n        {\\n            \"buttons\": [\\n                {\\n                    \"label\" : \"Play\",\\n                    \"method\" : \"animate\", #Affects animation\\n                    \"args\" : [None, frame_arguments(frame_duration)]\\n                },\\n                {\\n                    \"label\" : \"Pause\",\\n                    \"method\" : \"animate\",\\n                    #To FutureJake: This is jank you can\\'t just make a pause button by setting the frame duration to ten billion seconds [FIX]\\n                    #  To PastJake: Who\\'s going to stop me?\\n                    \"args\" : [None, frame_arguments(1000000000)]\\n                }\\n            ],\\n            #Position/display arguments for the buttons\\n            \"y\" : 0.5,\\n            \"yanchor\" : \"bottom\",\\n            \"xanchor\" : \"center\",\\n            \"type\" : \"buttons\"\\n        },\\n        {\\n            \"buttons\": [\\n                {\\n                    \"label\" : \"Lightmode\",\\n                    \"method\" : \"relayout\", #Affects layout attributes\\n                    \"args\" : [\"template\", pio.templates[\"plotly_white\"]]\\n                },\\n                {\\n                    \"label\" : \"Darkmode\",\\n                    \"method\" : \"relayout\", #Affects layout attributes\\n                    \"args\" : [\"template\", pio.templates[\"plotly_dark\"]]\\n                }\\n            ],\\n            \"y\" : 0.4,\\n            \"yanchor\" : \"top\",\\n            \"xanchor\" : \"center\",\\n            \"direction\" : \"down\",\\n            \"type\" : \"dropdown\"\\n        }\\n    ]\\n)        \\n\\n#Finally, render the figure\\nfig.show()\\n'\n\n\n\n\nCode\nimport plotly.graph_objects as go\nimport numpy as np\n\n#Curve parameters\nperiod    = 50\nn_samples = 100\nsim_time  = period*10\n\nx = np.arange(n_samples)*np.pi/period\n\nfig = go.Figure(go.Scatter(x=x, y=np.sin(x), mode='lines', name='Testing Points'))\nfig.update_layout(title='Animation Test',\n                  title_x=0.5,\n                  width=600, height=600, \n                  xaxis_title='time', \n                  yaxis_title='E',\n                  yaxis_range=(-1.5, 1.5),\n                  xaxis_range=(0,2*np.pi),\n                  #defines the play button and animation settings\n                  updatemenus=[dict(buttons = [dict(\n                                               args = [None, {\"frame\": {\"duration\": period, \n                                                                        \"redraw\": False},\n                                                              \"fromcurrent\": True, \n                                                              \"transition\": {\"duration\": 0}}],\n                                               label = \"Play\",\n                                               method = \"animate\")],\n                                type='buttons',\n                                showactive=False,\n                                xanchor='right',\n                                yanchor='top')])\n                                          \nframes= [go.Frame(data=[go.Scatter(x=x, y=np.sin(x+t*np.pi/period))]) for t in range(1, sim_time)]\nfig.update(frames=frames)\n\nfig.show()"
  },
  {
    "objectID": "contact.html",
    "href": "contact.html",
    "title": "contact",
    "section": "",
    "text": "text text text"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "about",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "about_jake.html",
    "href": "about_jake.html",
    "title": "Jake Ferguson",
    "section": "",
    "text": "Jake (he/him) is a PhD Candidate in Geography and Environmental Management at the University of Waterloo. He’s interested in SAR Interferometry, SAR Polarimetry, physics education, and fussing over his website’s plotly renders.\nTo see an image of me, click here\n\n\n\nEducation\nUniversity of Waterloo | Waterloo, CA\nMSc. Physics, Computational Multiphysics Group | August 2019\nUniversity of Waterloo | Waterloo, CA\nBSc. Physics | April 2017\n\n\nSelect pubs\nPolarimetric decomposition of microwave-band freshwater ice SAR data: Review, analysis, and future directions\n\n\n\n\nRecommended Reading\nwhy is this not updating"
  },
  {
    "objectID": "index.html#what-is-polarization-state",
    "href": "index.html#what-is-polarization-state",
    "title": "jf_web",
    "section": "What is Polarization State?",
    "text": "What is Polarization State?\n\nWhat is degree of polarization?\nIn reality, most EMR is not “perfectly polarized” as it was above. EMR can often be viewed as sums of waves with different frequencies. Try adding two different waves together to make strange new waveforms:\n\n\nCode\nviewof form_m1_1 = Inputs.form(\n    [\n        Inputs.range([1, 30], {label: html`&lt;font size=\"3.5\"&gt;Amplitude 1&lt;/font&gt;`, step: 1, value: 15}),\n        Inputs.range([1, 100], {label: html`&lt;font size=\"3.5\"&gt;Wavelength 1&lt;/font&gt;`, step: 1, value: 50})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\namplitudeW1  = form_m1_1[0];\nwavelengthW1 = form_m1_1[1];\n\nviewof form_m1_2 = Inputs.form(\n    [\n        Inputs.range([1, 30], {label: html`&lt;font size=\"3.5\"&gt;Amplitude 2&lt;/font&gt;`, step: 1, value: 15}),\n        Inputs.range([1, 100], {label: html`&lt;font size=\"3.5\"&gt;Wavelength 2&lt;/font&gt;`, step: 1, value: 50})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\n\namplitudeW2  = form_m1_2[0];\nwavelengthW2 = form_m1_2[1];\n\nviewof form_m1_3 = Inputs.form(\n    [\n        Inputs.range([0, 6.2], {label: html`&lt;font size=\"3.5\"&gt;Phase Diff&lt;/font&gt;`, step: 0.1, value: 0}),\n        Inputs.range([1, 20], {label: html`&lt;font size=\"3.5\"&gt;Speed&lt;/font&gt;`, step: 1, value: 10})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\n\nphase_diff_m1  = form_m1_3[0];\nspeed_m1 = form_m1_3[1];\n\n\ndistance = 400;\nNumPoints = 1000;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwave1 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitudeW1 * Math.sin(j * 2*Math.PI / wavelengthW1 + time)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwave2 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitudeW2 * Math.sin(j * 2*Math.PI / wavelengthW2 + time + phase_diff_m1)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwaveSum = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitudeW1 * Math.sin(j * 2*Math.PI / wavelengthW1 + time) + amplitudeW2 * Math.sin(j * 2*Math.PI / wavelengthW2 + time + phase_diff_m1)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\ntime = {\n  let i = 0;\n  while (true) {\n    i += speed_m1 * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\nr = d3.line()(wave1);\nb = d3.line()(wave2);\nsvg`&lt;svg viewBox=\"0 -32 400 64\"&gt;\n  &lt;path d=\"${r}\" stroke=\"red\" fill=\"none\" /&gt;\n  &lt;path d=\"${b}\" stroke=\"blue\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\np = d3.line()(waveSum);\nsvg`&lt;svg viewBox=\"0 -64 400 130\"&gt;\n  &lt;path d=\"${p}\" stroke=\"black\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n But that’s just two “pure” waves – what happens when EMR is the sum of many waves of different frequencies? Try adding more and more waves of different frequencies, uniformly distributed in a small band: \n\n\nCode\nviewof form_m2_1 = Inputs.form(\n    [\n        Inputs.range([1, 10], {label: \"# of Waves\", step: 1, value: 1}),\n        Inputs.range([1, 20], {label: \"Speed\", step: 1, value: 10})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\nNumWaves_m2 = form_m2_1[0];\nspeed_m2    = form_m2_1[1];\n\namplitude_m2 = 6;\ndistance_m2 = 400;\nNumPoints_m2 = 1000;\nwavelengths_m2 = [30,29,25,33,36,24,28,35,40,22,37];\nphases_m2 = [0,0,1,0.5,2,3.1,4,4.9,1.3,.8,6];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwaveSum_m2 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints_m2; i++) {\n        var y = 0\n        for (var k = 1; k &lt;= NumWaves_m2; k++) {\n            var j = i * distance_m2 / NumPoints_m2;\n            y += amplitude_m2 * Math.sin(j * 2*Math.PI / wavelengths_m2[k] + time_m2 + phases_m2[k])\n        }\n        data.push([j,y]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\ntime_m2 = {\n  let i = 0;\n  while (true) {\n    i += speed_m2 * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\nsummed_wave_m2 = d3.line()(waveSum_m2);\nsvg`&lt;svg viewBox=\"0 -50 400 85\"&gt;\n  &lt;path d=\"${summed_wave_m2}\" stroke=\"black\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n The waveform is… complex now, to say the least. It might not even be periodic anymore! But how can we concretely define this notion of “coherence”? Technically the wave is well-defined everywhere in space here. Indeed if we knew the underlying ten pure waves, we could know exactly what this ugly wave is doing everywhere in space.\nBut in reality we don’t have the luxury of perfectly measuring the wave at every position for all time. We have to make do with sampling a subset of it. Let’s consider a pure state again, where we measure the value of a portion over time and see how much that information constrains the wave’s behaviour at another position: \n\n\nCode\nviewof form_m3_1 = Inputs.form(\n    [\n        Inputs.range([5, 50], {label: \"Wavelength\",    step: 1}),\n        Inputs.range([1, 10], {label: \"Speed\", step: 1}),\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\nwavelength_m3 = form_m3_1[0];\nspeed_m3      = form_m3_1[1]\n\nviewof form_m3_2 = Inputs.form(\n    [\n        Inputs.range([500, 850], {label: \"Delay\", step: 5, value: 640}),\n        Inputs.button(\"Toggle Wave\")\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\nd5x_m3  = form_m3_2[0];\nvtoggle = form_m3_2[1]\n\n\n\n//viewof wavelength_m3    = Inputs.range([5, 50], {label: \"Wavelength\",    step: 1});\n//viewof speed_m3     = Inputs.range([1, 10], {label: \"Speed\", step: 1});\n//viewof d5x_m3       = Inputs.range([500, 850], {label: \"Delay\", step: 5, value: 640});\n//viewof vtoggle      = Inputs.button(\"Toggle Wave\")\n\nd1x_m3 = 100;\nd2x_m3 = 110;\nd3x_m3 = 120;\nd4x_m3 = 130;\n\nobservation_time = 400;\namplitude_m3 = 25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwave_m3 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitude_m3 * Math.sin(j * 2*Math.PI / wavelength_m3 + time_m3)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nd1y_m3 = wave_m3[d1x_m3][1];\nd2y_m3 = wave_m3[d2x_m3][1];\nd3y_m3 = wave_m3[d3x_m3][1];\nd4y_m3 = wave_m3[d4x_m3][1];\nd5y_m3 = wave_m3[d5x_m3][1];\nvisible = {\n  if(vtoggle % 2 == 0){return \"black\"}\n  else{return \"white\"}\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ntime_m3 = {\n  let i = 0;\n  while (true) {\n    i += speed_m3 * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\nout_m3 = d3.line()(wave_m3);\nsvg`&lt;svg viewBox=\"0 -50 400 85\"&gt;\n  &lt;path d=\"${out_m3}\" stroke=${visible} fill=\"none\" /&gt;\n  &lt;circle cx=${d1x_m3 * distance / NumPoints} cy=${d1y_m3} r=\"2.5\" fill=\"red\"/&gt;\n  &lt;circle cx=${d2x_m3 * distance / NumPoints} cy=${d2y_m3} r=\"2.5\" fill=\"DarkOrange\"/&gt;\n  &lt;circle cx=${d3x_m3 * distance / NumPoints} cy=${d3y_m3} r=\"2.5\" fill=\"DarkOrange\"/&gt;\n  &lt;circle cx=${d4x_m3 * distance / NumPoints} cy=${d4y_m3} r=\"2.5\" fill=\"DarkOrange\"/&gt;\n  &lt;circle cx=${d5x_m3 * distance / NumPoints} cy=${d5y_m3} r=\"2.5\" fill=\"blue\"/&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n//y(t) for the measured point of the wave (red dot)\np1_t = {\n    var p1_t = [];\n    for (var t =1; t &lt;= observation_time; t++){\n        var j = d1x_m3 * distance / NumPoints;\n        var k = t / wavelength_m3;\n        p1_t.push([k,amplitude_m3 * Math.sin(j * 2*Math.PI / wavelength_m3 + k)]);\n    }\n    return p1_t;\n}\n\n\n\n\n\n\n\n\n\nCode\n//y(t) for the hypothetical point of the wave (blue dot)\np2_t = {\n    var p2_t = [];\n    for (var t =1; t &lt;= observation_time; t++){\n        var j = d5x_m3 * distance / NumPoints;\n        var k = t / wavelength_m3;\n        p2_t.push([k,amplitude_m3 * Math.sin(j * 2*Math.PI / wavelength_m3 + k)]);\n    }\n    return p2_t;\n}\n\n\n\n\n\n\n\n\n\nCode\nplot1_m3 = Plot.plot({\n    height: 200,\n    width: width/2,\n    x: {line: true},\n    y: {grid:true},\n    fill: \"red\",\n    marks: [\n        Plot.line(p1_t, {stroke:\"red\", strokeWidth:3})\n    ]\n})\n\n\n\n\n\n\n\n\n\nCode\nplot2_m3 = Plot.plot({\n    height: 200,\n    width: width/2,\n    x: {line: true},\n    y: {grid:true},\n    stroke: \"blue\",\n    marks: [\n        Plot.line(p2_t, {stroke:\"blue\", strokeWidth:3})\n    ]\n})\n\n\n\n\n\n\n\n\n\nCode\nhtml`&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n    &lt;div class=\"container\" style=\"display: flex; height: 300px;\"&gt;\n        &lt;div style=\"width: 50%;\"&gt;\n            ${plot1_m3}\n        &lt;/div&gt;\n        &lt;div style=\" width: 50%;\"&gt;\n            ${plot2_m3}\n        &lt;/div&gt;\n    &lt;/div&gt;\n &lt;/body&gt;\n&lt;/html&gt;`\n\n\n\n\n\n\n\nEvidently"
  }
]