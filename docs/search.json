[
  {
    "objectID": "teaching/coherence_and_polarization/visualizing_coherence.html",
    "href": "teaching/coherence_and_polarization/visualizing_coherence.html",
    "title": "Visualizing Coherence",
    "section": "",
    "text": "The waveform is… complex now, to say the least. It might not even be periodic anymore! But how can we concretely define this notion of “coherence”? Technically the wave is well-defined everywhere in space here. Indeed if we knew the underlying ten pure waves, we could know exactly what this ugly wave is doing everywhere in space.\nBut in reality we don’t have the luxury of perfectly measuring the wave at every position for all time. We have to make do with sampling a subset of it. Let’s consider a pure state again, where we measure the value of a portion over time and see how much that information constrains the wave’s behaviour at another position: \n\n\nCode\nviewof form_m3_1 = Inputs.form(\n    [\n        Inputs.range([5, 50], {label: \"Wavelength\",    step: 1, value: 35}),\n        Inputs.range([1, 20], {label: \"Speed\", step: 1, value: 10}),\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\nwavelength_m3 = form_m3_1[0];\nspeed_m3      = form_m3_1[1]\n\nviewof form_m3_2 = Inputs.form(\n    [\n        Inputs.range([500, 850], {label: \"Delay\", step: 5, value: 640}),\n        Inputs.button(\"Toggle Wave\")\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\nd5x_m3  = form_m3_2[0];\nvtoggle = form_m3_2[1]\n\n\n\n//viewof wavelength_m3    = Inputs.range([5, 50], {label: \"Wavelength\",    step: 1});\n//viewof speed_m3     = Inputs.range([1, 10], {label: \"Speed\", step: 1});\n//viewof d5x_m3       = Inputs.range([500, 850], {label: \"Delay\", step: 5, value: 640});\n//viewof vtoggle      = Inputs.button(\"Toggle Wave\")\n\nd1x_m3 = 100;\nd2x_m3 = 110;\nd3x_m3 = 120;\nd4x_m3 = 130;\n\nobservation_time = 400;\namplitude_m3 = 25;\n\ndistance = 400;\nNumPoints = 1000;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwave_m3 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitude_m3 * Math.sin(j * 2*Math.PI / wavelength_m3 + time_m3)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nd1y_m3 = wave_m3[d1x_m3][1];\nd2y_m3 = wave_m3[d2x_m3][1];\nd3y_m3 = wave_m3[d3x_m3][1];\nd4y_m3 = wave_m3[d4x_m3][1];\nd5y_m3 = wave_m3[d5x_m3][1];\nvisible = {\n  if(vtoggle % 2 == 0){return \"black\"}\n  else{return \"white\"}\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ntime_m3 = {\n  let i = 0;\n  while (true) {\n    i += speed_m3 * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\nout_m3 = d3.line()(wave_m3);\nsvg`&lt;svg viewBox=\"0 -50 400 85\"&gt;\n  &lt;path d=\"${out_m3}\" stroke=${visible} fill=\"none\" /&gt;\n  &lt;circle cx=${d1x_m3 * distance / NumPoints} cy=${d1y_m3} r=\"2.5\" fill=\"red\"/&gt;\n  &lt;circle cx=${d2x_m3 * distance / NumPoints} cy=${d2y_m3} r=\"2.5\" fill=\"DarkOrange\"/&gt;\n  &lt;circle cx=${d3x_m3 * distance / NumPoints} cy=${d3y_m3} r=\"2.5\" fill=\"DarkOrange\"/&gt;\n  &lt;circle cx=${d4x_m3 * distance / NumPoints} cy=${d4y_m3} r=\"2.5\" fill=\"DarkOrange\"/&gt;\n  &lt;circle cx=${d5x_m3 * distance / NumPoints} cy=${d5y_m3} r=\"2.5\" fill=\"blue\"/&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n//y(t) for the measured point of the wave (red dot)\np1_t = {\n    var p1_t = [];\n    for (var t =1; t &lt;= observation_time; t++){\n        var j = d1x_m3 * distance / NumPoints;\n        var k = t / wavelength_m3;\n        p1_t.push([k,amplitude_m3 * Math.sin(j * 2*Math.PI / wavelength_m3 + k)]);\n    }\n    return p1_t;\n}\n\n\n\n\n\n\n\n\n\nCode\n//y(t) for the hypothetical point of the wave (blue dot)\np2_t = {\n    var p2_t = [];\n    for (var t =1; t &lt;= observation_time; t++){\n        var j = d5x_m3 * distance / NumPoints;\n        var k = t / wavelength_m3;\n        p2_t.push([k,amplitude_m3 * Math.sin(j * 2*Math.PI / wavelength_m3 + k)]);\n    }\n    return p2_t;\n}\n\n\n\n\n\n\n\n\n\nCode\nplot1_m3 ={\n  var p = Plot.plot({\n    height: 200,\n    width: width/2,\n    x: {line: true, label: \"time\", ticks:0, anchor:\"bottom\", labelAnchor: \"center\"},\n    y: {label: \"amplitude\", ticks:0, anchor:\"left\", labelAnchor:\"center\"},\n    fill: \"red\",\n    marks: [\n        Plot.line(p1_t, {stroke:\"red\", strokeWidth:3})\n    ]\n  })\n  p.setAttribute(\"font-size\", 18);\n  return p\n}\n\n\n\n\n\n\n\n\n\nCode\nplot2_m3 = {\n    var p = Plot.plot({\n        height: 200,\n        width: width/2,\n        x: {line: true, label: \"time\", ticks:0, anchor:\"bottom\", labelAnchor: \"center\"},\n        y: {label: \"amplitude\", ticks:0, anchor:\"left\", labelAnchor:\"center\"},\n        stroke: \"blue\",\n        marks: [\n            Plot.line(p2_t, {stroke:\"blue\", strokeWidth:3})\n        ]\n    })\n  p.setAttribute(\"font-size\", 18);\n  return p\n}\n\n\n\n\n\n\n\n\n\nCode\nhtml`&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n    &lt;div class=\"container\" style=\"display: flex; height: 300px;\"&gt;\n        &lt;div style=\"width: 50%;\"&gt;\n            ${plot1_m3}\n        &lt;/div&gt;\n        &lt;div style=\" width: 50%;\"&gt;\n            ${plot2_m3}\n        &lt;/div&gt;\n    &lt;/div&gt;\n &lt;/body&gt;\n&lt;/html&gt;`"
  },
  {
    "objectID": "teaching/coherence_and_polarization/sums_of_waves.html",
    "href": "teaching/coherence_and_polarization/sums_of_waves.html",
    "title": "Sums of Waves",
    "section": "",
    "text": "Remote sensing involves measuring light’s physical properties to determine what type of object it was emitted by or interacted with. Properties like energy and wavelength/frequency are straightforward enough to undertand and represent diagrammatically – however we often want to observe and explain more unintuitive properties like coherence or polarization state.\nThese properties are the basis of powerful techniques such as radar polarimetry, but they’re notoriously tricky to represent and absorb – it certainly doesn’t help that we need to visualize 4D objects, or that the properties are similar yet distinct, intimately related through statistics! Don’t worry though – here we will walk comfortably from first principles up to a working understanding of coherence and polarization state. And if you’re particularly brave continue on and we’ll tie them together under the umbrella of information theory by relating them to Shannon entropy."
  },
  {
    "objectID": "teaching/coherence_and_polarization/sums_of_waves.html#what-is-coherence-what-is-polarization-state",
    "href": "teaching/coherence_and_polarization/sums_of_waves.html#what-is-coherence-what-is-polarization-state",
    "title": "Sums of Waves",
    "section": "What is Coherence? What is Polarization State?",
    "text": "What is Coherence? What is Polarization State?\nIn reality, most EMR is not “perfectly polarized”. EMR can often be viewed as sums of waves with different frequencies. Try adding two different waves together to make strange new waveforms:\n\n\nCode\nviewof form_m1_1 = Inputs.form(\n    [\n        Inputs.range([1, 30], {label: html`&lt;font size=\"3.5\"&gt;Amplitude 1&lt;/font&gt;`, step: 1, value: 15}),\n        Inputs.range([1, 100], {label: html`&lt;font size=\"3.5\"&gt;Wavelength 1&lt;/font&gt;`, step: 1, value: 50})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\namplitudeW1  = form_m1_1[0];\nwavelengthW1 = form_m1_1[1];\n\nviewof form_m1_2 = Inputs.form(\n    [\n        Inputs.range([1, 30], {label: html`&lt;font size=\"3.5\"&gt;Amplitude 2&lt;/font&gt;`, step: 1, value: 15}),\n        Inputs.range([1, 100], {label: html`&lt;font size=\"3.5\"&gt;Wavelength 2&lt;/font&gt;`, step: 1, value: 50})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\n\namplitudeW2  = form_m1_2[0];\nwavelengthW2 = form_m1_2[1];\n\nviewof form_m1_3 = Inputs.form(\n    [\n        Inputs.range([0, 6.2], {label: html`&lt;font size=\"3.5\"&gt;Phase Diff&lt;/font&gt;`, step: 0.1, value: 0}),\n        Inputs.range([1, 20], {label: html`&lt;font size=\"3.5\"&gt;Speed&lt;/font&gt;`, step: 1, value: 10})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\n\nphase_diff_m1  = form_m1_3[0];\nspeed_m1 = form_m1_3[1];\n\n\ndistance = 400;\nNumPoints = 1000;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwave1_m1 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitudeW1 * Math.sin(j * 2*Math.PI / wavelengthW1 + time)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwave2_m1 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitudeW2 * Math.sin(j * 2*Math.PI / wavelengthW2 + time + phase_diff_m1)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwaveSum_m1 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j , amplitudeW1 * Math.sin(j * 2*Math.PI / wavelengthW1 + time) + amplitudeW2 * Math.sin(j * 2*Math.PI / wavelengthW2 + time + phase_diff_m1)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\ntime = {\n  let i = 0;\n  while (true) {\n    i += speed_m1 * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\nr = d3.line()(wave1_m1);\nb = d3.line()(wave2_m1);\nsvg`&lt;svg viewBox=\"0 -32 400 64\"&gt;\n  &lt;path d=\"${r}\" stroke=\"red\" fill=\"none\" /&gt;\n  &lt;path d=\"${b}\" stroke=\"blue\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\np = d3.line()(waveSum_m1);\nsvg`&lt;svg viewBox=\"0 -64 400 130\"&gt;\n  &lt;path d=\"${p}\" stroke=\"black\" fill=\"none\" /&gt;\n&lt;/svg&gt;`"
  },
  {
    "objectID": "teaching/coherence_and_polarization/polarization_state_pure.html",
    "href": "teaching/coherence_and_polarization/polarization_state_pure.html",
    "title": "Polarization State (Pure)",
    "section": "",
    "text": "Use the sliders below to explore polarization state as expressed in a linear basis (e.g. V/H)\n\n\nCode\nviewof form1 = Inputs.form(\n    [\n        Inputs.range([0, 20], {label: \"Amplitude 1\",    step: 1, value: 10}),\n        Inputs.range([0, 20], {label: \"Amplitude 2\", step: 1, value: 10}),\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\namplitude_1 = form1[0];\namplitude_2 = form1[1];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nviewof form2 = Inputs.form(\n    [\n        Inputs.range([0, 6.2], {label: \"Phase Diff\", step: 0.1, value: 0})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\n\nphase_diff  = form2[0];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nviewof form3 = Inputs.form(\n    [\n        Inputs.button(\"Toggle Sum\"),\n        Inputs.button(\"Toggle H and V\")\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\n\nvtoggle1    = form3[0];\nvtoggle2    = form3[1];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nl1_color = {return 0xff0000}\nl2_color = {return 0x0000ff}\nl3_color = {return 0x36454f}\n\nrender_l1l2 = {\n    if(vtoggle2 % 2 == 0){return true}\n        else{return false}\n}\n\nrender_l3 = {\n    if(vtoggle1 % 2 == 0){return false}\n        else{return true}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n{\n    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});\n    invalidation.then(() =&gt; renderer.dispose());\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(devicePixelRatio);\n    renderer.setClearColor( 0xffffff, 0 )\n    \n    const controls = new THREE.OrbitControls(camera, renderer.domElement);\n    controls.addEventListener(\"change\", () =&gt; renderer.render(scene, camera));\n    invalidation.then(() =&gt; (controls.dispose(), renderer.dispose()));\n    \n    while (true) {\n        renderer.render(scene, camera);\n        yield renderer.domElement;\n    }\n}\n\n\n\n\n\n\n\n\n\nCode\nscene = {\n  const scene = new THREE.Scene();\n  scene.background = null;\n  if (render_l1l2 == true){\n    scene.add(line1);\n    scene.add(line2);\n  };\n  if (render_l3 == true){\n    scene.add(line3)\n  };\n  return scene;\n}\n\n\n\n\n\n\n\n\n\nCode\nline1 = {\n    const material = new THREE.LineMaterial({\n        color: l1_color,\n        linewidth: 3,\n    });\n\n    material.resolution.set(width, height);\n\n    const points = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        points.push( i-NumPoints/2, 0, 2*amplitude_1*Math.sin(i/10) );\n    }\n\n    const geometry = new THREE.LineGeometry().setPositions( points );\n    const line = new THREE.Line2( geometry, material );\n    return line;\n}\n\nline2 = {\n    const material = new THREE.LineMaterial({\n        color: l2_color,\n        linewidth: 3,\n    });\n\n    material.resolution.set(width, height);\n\n    const points = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        points.push( i-NumPoints/2, 2*amplitude_2*Math.sin(i/10 + phase_diff), 0);\n    }\n\n    const geometry = new THREE.LineGeometry().setPositions( points );\n    const line = new THREE.Line2( geometry, material );\n    return line;\n}\n\nline3 = {\n    const material = new THREE.LineMaterial({\n        color: l3_color,\n        linewidth: 3,\n    });\n\n    material.resolution.set(width, height);\n\n    const points = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        points.push(i-NumPoints/2, 2*amplitude_2*Math.sin(i/10 + phase_diff), 2*amplitude_1*Math.sin(i/10));\n    }\n\n    const geometry = new THREE.LineGeometry().setPositions( points );\n    const line = new THREE.Line2( geometry, material );\n    return line;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncamera = {\n    const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );\n    camera.position.set( 100, 100, 100 );\n    camera.lookAt( 0, 0, 0 );\n    return camera;\n}\n\n\n\n\n\n\n\n\n\nCode\nheight = 600;\nNumPoints = 200;\nNumPoints_ellipse = 200;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nversion=`0.130.0`;\nTHREE = {\n    const THREE = window.THREE = await require(`three@${version}/build/three.min.js`);\n    await require(`three@${version}/examples/js/controls/OrbitControls.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineSegments2.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineSegmentsGeometry.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/Line2.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineGeometry.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineMaterial.js`).catch(() =&gt; {});\n\n    return THREE;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLooking at this mono-frequency wave head-on, we can see that the electric field vector traces out an ellipse. Each combination of power in the V, power in the H and phase difference corresponds to a unique ellipse. Thus when we think about all the ways a pure wave could be polarization-wise, we can use two equivalent classes of description. Describe the basis waves (Power in the V, power in the H, and their phase difference) or the polarization ellipse (e.g. length of major axis, length of minor axis, angle of orientation).\n\n\nCode\nellipse_points = {\n    var data = [];\n    for (var i = 1; i&lt;=NumPoints_ellipse;i++){\n        data.push([2*amplitude_1*Math.sin(i/10), 2*amplitude_2*Math.sin(i/10 + phase_diff)])\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nellipse = d3.line()(ellipse_points);\nsvg`&lt;svg viewBox=\"-50 -50 100 100\"&gt;\n  &lt;path d=\"${ellipse}\" stroke=\"gray\" fill=\"none\" /&gt;\n&lt;/svg&gt;`"
  },
  {
    "objectID": "teaching/coherence_and_polarization/polarization_state_general.html",
    "href": "teaching/coherence_and_polarization/polarization_state_general.html",
    "title": "Polarization State (General)",
    "section": "",
    "text": "In reality however a wave is rarely ever perfectly of mono-frequency. Let’s see what happens when we substitute each of the original mono-frequency V and H waves with waves formed of multiple random nearby frequencies.\n\n\nCode\nviewof form1 = Inputs.form(\n    [\n        Inputs.range([1, 10], {label: \"# of Waves in V\",    step: 1, value: 1}),\n        Inputs.range([1, 10], {label: \"# of Waves in H\", step: 1, value: 1}),\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\nnum_waves_V = form1[0];\nnum_waves_H = form1[1];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nviewof form3 = Inputs.form(\n    [\n        Inputs.button(\"Toggle Sum\"),\n        Inputs.button(\"Toggle H and V\")\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\n\nvtoggle1    = form3[0];\nvtoggle2    = form3[1];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nH_color = {return 0xff0000}\nV_color = {return 0x0000ff}\nS_color = {return 0x36454f}\n\nrender_HV = {\n    if(vtoggle2 % 2 == 0){return true}\n        else{return false}\n}\n\nrender_S = {\n    if(vtoggle1 % 2 == 0){return false}\n        else{return true}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n{\n    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});\n    invalidation.then(() =&gt; renderer.dispose());\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(devicePixelRatio);\n    renderer.setClearColor( 0xffffff, 0 )\n    \n    const controls = new THREE.OrbitControls(camera, renderer.domElement);\n    controls.addEventListener(\"change\", () =&gt; renderer.render(scene, camera));\n    invalidation.then(() =&gt; (controls.dispose(), renderer.dispose()));\n    \n    while (true) {\n        renderer.render(scene, camera);\n        yield renderer.domElement;\n    }\n}\n\n\n\n\n\n\n\n\n\nCode\nscene = {\n  const scene = new THREE.Scene();\n  scene.background = null;\n  if (render_HV == true){\n    scene.add(line1);\n    scene.add(line2);\n  };\n  if (render_S == true){\n    scene.add(line3)\n  };\n  return scene;\n}\n\n\n\n\n\n\n\n\n\nCode\nline1 = {\n    const material = new THREE.LineMaterial({\n        color: V_color,\n        linewidth:3,\n    });\n\n    material.resolution.set(width, height);\n\n    const points = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var y= 0;\n        for (var j=0; j &lt; num_waves_V; j++){\n            y += (10 + 10/num_waves_V) * Math.sin(i/wavelengths_v[j] + phases[j])\n        }\n        points.push(i-NumPoints/2, y, 0);\n    }\n\n    const geometry = new THREE.LineGeometry().setPositions( points );\n    const line = new THREE.Line2( geometry, material );\n    return line;\n}\n\nline2 = {\n    const material = new THREE.LineMaterial({\n        color: H_color,\n        linewidth: 3,\n    });\n\n    material.resolution.set(width, height);\n\n    const points = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var x= 0;\n        for (var j=0; j &lt; num_waves_H; j++){\n            x += (10 + 10/num_waves_H) * Math.sin(i/wavelengths_h[j] + phases[j])\n        }\n        points.push(i-NumPoints/2, 0, x);\n    }\n\n    const geometry = new THREE.LineGeometry().setPositions( points );\n    const line = new THREE.Line2( geometry, material );\n    return line;\n}\n\n\nline3 = {\n    const material = new THREE.LineMaterial({\n        color: S_color,\n        linewidth:3,\n    });\n\n    material.resolution.set(width, height);\n\n    const points = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var x = 0;\n        for (var j=0; j &lt; num_waves_H; j++){\n            x += (10 + 10/num_waves_H) * Math.sin(i/wavelengths_h[j] + phases[j])\n        }\n        var y = 0;\n        for (var k=0; k &lt; num_waves_V; k++){\n            y += (10 + 10/num_waves_V) * Math.sin(i/wavelengths_v[k] + phases[k])\n        }\n        points.push(i-NumPoints/2, y, x);\n    }\n\n    const geometry = new THREE.LineGeometry().setPositions( points );\n    const line = new THREE.Line2( geometry, material );\n    return line;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncamera = {\n    const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );\n    camera.position.set( 100, 100, 100 );\n    camera.lookAt( 0, 0, 0 );\n    return camera;\n}\n\n\n\n\n\n\n\n\n\nCode\nheight = 600;\nNumPoints = 200;\nNumPoints_ellipse = 200;\n\npeturbv = [0,-1,5,-2,-3,2,3,-5,-6,4]\nwavelengths_v = {\n    var data = [];\n    for (var i=0; i&lt;10; i++){\n        data.push(10+peturbv[i]*.2)\n    }\n    return data;\n}\n\npeturbh = [0,-3,1,-4,-1,6,5,-5,-2,3]\nwavelengths_h = {\n    var data = [];\n    for (var i=0; i&lt;10; i++){\n        data.push(10+peturbh[i]*.2)\n    }\n    return data;\n}\n\nphases = [0,0,1,0.5,2,3.1,4,4.9,1.3,.8,6];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nversion=`0.130.0`;\nTHREE = {\n    const THREE = window.THREE = await require(`three@${version}/build/three.min.js`);\n    await require(`three@${version}/examples/js/controls/OrbitControls.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineSegments2.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineSegmentsGeometry.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/Line2.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineGeometry.js`).catch(() =&gt; {});\n    await require(`three@${version}/examples/js/lines/LineMaterial.js`).catch(() =&gt; {});\n\n    return THREE;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nellipse_points = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var x = 0;\n        for (var j=0; j &lt; num_waves_H; j++){\n            x += (5 + 10/num_waves_H) * Math.sin(i/wavelengths_h[j] + phases[j])\n        }\n        var y = 0;\n        for (var k=0; k &lt; num_waves_V; k++){\n            y += (5 + 10/num_waves_V)  * Math.sin(i/wavelengths_v[k] + phases[k])\n        }\n        data.push([-x,-y]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nellipse = d3.line()(ellipse_points);\nsvg`&lt;svg viewBox=\"-50 -50 100 100\"&gt;\n  &lt;path d=\"${ellipse}\" stroke=\"gray\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOur earlier notion of wave coherence in 2D has moved into 3D adding a fourth polarization parameter: the degree of polarization. DOP is a measure of the degree of correlation between the wave’s geometric oscillations in time. We can then describe a polarization state in terms of some “average” pure state (3 parameters) which is deviated from by an amount commensurate to the degree of polarization (1 parameter). Although we might expect there to be infinitely many distinct curves with the same corresponding pure state and degree of polarization, in practice the distinction is unimportant as those states share the same physical properties in the aggregate. This gives fits nicely with experimentally-obtained descriptions of polarization such as the Stokes parameters."
  },
  {
    "objectID": "teaching/coherence_and_polarization/getting_incoherent.html",
    "href": "teaching/coherence_and_polarization/getting_incoherent.html",
    "title": "Getting Incoherent",
    "section": "",
    "text": "But that’s just two “pure” waves – what happens when EMR is the sum of many waves of different frequencies? Try adding more and more waves of different frequencies, uniformly distributed in a small range (or band): \n\n\nCode\nviewof form_m2_1 = Inputs.form(\n    [\n        Inputs.range([1, 10], {label: \"# of Waves\", step: 1, value: 1}),\n        Inputs.range([1, 20], {label: \"Speed\", step: 1, value: 10})\n    ],\n    {\n        template: (inputs) =&gt; htl.html`&lt;div style=\"display: flex; gap: 1em\"&gt;\n        ${inputs}\n        &lt;/div&gt;`\n    }\n)\nNumWaves_m2 = form_m2_1[0];\nspeed_m2    = form_m2_1[1];\n\namplitude_m2 = 6;\ndistance_m2 = 400;\nNumPoints_m2 = 1000;\nwavelengths_m2 = [30,29,25,33,36,24,28,35,40,22,37];\nphases_m2 = [0,0,1,0.5,2,3.1,4,4.9,1.3,.8,6];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwaveSum_m2 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints_m2; i++) {\n        var y = 0\n        for (var k = 1; k &lt;= NumWaves_m2; k++) {\n            var j = i * distance_m2 / NumPoints_m2;\n            y += amplitude_m2 * Math.sin(j * 2*Math.PI / wavelengths_m2[k] + time_m2 + phases_m2[k])\n        }\n        data.push([j,y]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwaves_m2 = {\n    var waves = []\n    for (var i = 1; i &lt;= wavelengths_m2.length; i++) {\n        var data = [];\n        for (var k = 1; k &lt;= NumPoints_m2; k++) {\n            var j = k * distance_m2 / NumPoints_m2;\n            data.push([j , amplitude_m2* Math.sin(j * 2*Math.PI / wavelengths_m2[i] + time_m2 + phases_m2[i]) + amplitude_m2*2.4*(i+2)]);\n        }\n        waves.push(data)\n    }\n    return waves;\n}\n\n\n\n\n\n\n\n\n\nCode\ntime_m2 = {\n  let i = 0;\n  while (true) {\n    i += speed_m2 * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\ncolors_m2 = {\n    var colors = []\n    for (var i = 0; i &lt; wavelengths_m2.length; i++){\n        if (i &lt; NumWaves_m2){colors.push(\"red\")}\n        else {colors.push(\"white\")}\n    }\n    return colors\n}\n\nsummed_wave_m2 = d3.line()(waveSum_m2);\nw_m2 = d3.line()(waves_m2[0]);\nsvg`&lt;svg viewBox=\"0 -50 400 250\"&gt;\n  &lt;path d=\"${summed_wave_m2}\" stroke=\"black\" fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[0])}\" stroke=${colors_m2[0]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[1])}\" stroke=${colors_m2[1]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[2])}\" stroke=${colors_m2[2]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[3])}\" stroke=${colors_m2[3]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[4])}\" stroke=${colors_m2[4]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[5])}\" stroke=${colors_m2[5]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[6])}\" stroke=${colors_m2[6]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[7])}\" stroke=${colors_m2[7]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[8])}\" stroke=${colors_m2[8]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[9])}\" stroke=${colors_m2[9]} fill=\"none\" /&gt;\n  &lt;path d=\"${d3.line()(waves_m2[10])}\" stroke=${colors_m2[10]} fill=\"none\" /&gt;\n&lt;/svg&gt;`"
  },
  {
    "objectID": "teaching/coherence_and_polarization/speckle.html",
    "href": "teaching/coherence_and_polarization/speckle.html",
    "title": "Speckle as an interference phenomenon",
    "section": "",
    "text": "Let’s look an illustrative real-world manifestation of this conceptual framework. SAR images are subject to speckle, a type of image distortion or noise which affects pixels in a stochastic, multiplicative way. Why does this occur?\nConsider that the returned wave associated with a given pixel likely isn’t the result of a single interation with a single pointwise object. If multiple reflectors (or similarly, a continuous reflector) lie within the pixel, then the returned wave is the sum of multiple individual waves.\nLet’s imagine we have a pixel with two identical point reflectors lying within it. How does the returned wave change as a function of where those reflectors are located? Move the blue and red targets in the pixel below:\n\n\n\n\nCode\nchart = {\n    const svg = d3.create(\"svg\").attr(\"viewBox\", [0, 0, width, height])\n\n    // define a bounding rectangle\n    svg.append(\"rect\")\n        .attr(\"x\", width/7)\n        .attr(\"y\", stroke_width)\n        .attr(\"width\", 5*width/7)\n        .attr(\"height\", height - 2*stroke_width)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-width\", stroke_width)\n        .attr(\"fill-opacity\", 0.087124976) //This is a hard-coded value based on the prescribed physical parameters. It's hardcoded because it's easier than dealing with the resulting reactive dependencies since this cell should never be run again\n\n    // define data used for circles\n    const circles = d3.range(2).map(i =&gt; ({\n        x: (i+2) * width / 5,\n        y: (i+1) * height / 3,\n        index: i, \n    }));\n\n    // define circles as graphic objects\n    svg.selectAll(\"circle\")\n        .data(circles)\n        .join(\"circle\")\n            .attr(\"cx\", d =&gt; d.x)\n            .attr(\"cy\", d =&gt; d.y)\n            .attr(\"r\", radius)\n            .attr(\"fill\", d =&gt; d3.schemeCategory10[d.index * 3])\n            .attr(\"id\", function(d,i) {return i})\n            .call(drag)\n\n    return svg.node();\n}\n\n\n\n\n\n\n\n\n\nCode\nchart2 = {\n    const svg = d3.create(\"svg\").attr(\"viewBox\", [0, 0, width, height])\n\n    //define a function to take the canvas position of the leftside chart to the\n    //  corresponding region in the second chart\n    //  it's messy because I solved the system by hand and didn't simplify, RIP\n    //  to future Jake if I ever have to un-hardcode the object position values\n    function lineartransform(xposition){\n        return (2*height/5 - radius)/(5/7*width -2*radius-2)*xposition + width/7 + 2/5*height + radius/2 - (2*height/5 - radius)*(width/7+radius+1)/(5/7*width-2*radius-2)\n    }\n\n    // define a earth curvature line\n    svg.append(\"rect\")\n        .attr(\"x\", width/7)\n        .attr(\"y\", height - 2*stroke_width)\n        .attr(\"width\", 5*width/7)\n        .attr(\"height\", stroke_width/2)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-width\", stroke_width)\n        .attr(\"fill-opacity\", 0)\n\n    // define lines going from the target to the satellites (first, so they appear under them)\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 3*height/20)\n        .attr(\"x2\", lineartransform(x1))\n        .attr(\"y1\", 3*height/20)\n        .attr(\"y2\", height - 2*stroke_width)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"blue\")\n\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 3*height/20)\n        .attr(\"x2\", lineartransform(x2))\n        .attr(\"y1\", 3*height/20)\n        .attr(\"y2\", height - 2*stroke_width)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"red\")\n\n\n    // define a rectangle representing the satellite\n    svg.append(\"rect\")\n        .attr(\"x\", width/7 + height/10)\n        .attr(\"y\", height/10)\n        .attr(\"width\", height/10)\n        .attr(\"height\", height/10)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-width\", stroke_width)\n        .attr(\"fill-opacity\", .50)\n    \n    // define notches indicating the bounds of the pixel\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 2*height/5)\n        .attr(\"x2\", width/7 + 2*height/5)\n        .attr(\"y1\", height - 2*stroke_width)\n        .attr(\"y2\", height - 2*stroke_width - height/20)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"black\")\n\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 4*height/5)\n        .attr(\"x2\", width/7 + 4*height/5)\n        .attr(\"y1\", height - 2*stroke_width)\n        .attr(\"y2\", height - 2*stroke_width - height/20)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"black\")\n\n    // define data used for circles\n    const circles = d3.range(2).map(i =&gt; ({\n        x: (i+2) * width / 5,\n        y: (i+1) * height / 3,\n        index: i, \n    }));\n\n    // define circles as graphic objects\n    svg.selectAll(\"circle\")\n        .data(circles)\n        .join(\"circle\")\n            .attr(\"cx\", function(d,i) {\n                if (i == 0) {return lineartransform(x1)}\n                else {return lineartransform(x2)}\n            })\n            .attr(\"cy\", height - 2*stroke_width)\n            .attr(\"r\", radius/2)\n            .attr(\"fill\", d =&gt; d3.schemeCategory10[d.index * 3])\n            .attr(\"id\", function(d,i) {return i})\n\n    // add text\n    svg.append(\"text\")\n        .attr(\"x\", width/7)\n        .attr(\"y\", .94*height)\n        .style(\"font-size\", \"28px\")\n        .text(\"side view\")\n\n    svg.append(\"text\")\n        .attr(\"x\", width/2)\n        .attr(\"y\", .15*height)\n        .style(\"font-size\", \"24px\")\n        .style(\"font-style\", \"italic\")\n        .text(\"*wildly not to scale\")\n\n    return svg.node();\n}\n\n\n\n\n\n\n\n\n\n\n\nCode\nformatted_d1 = (0.5*distance_travelled_w1).toFixed(2).replace(/\\B(?&lt;!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, \",\");\nformatted_d2 = (0.5*distance_travelled_w2).toFixed(2).replace(/\\B(?&lt;!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, \",\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistance from target one to the satellite: m\nDistance from target two to the satellite: m\n\n\n\nCode\n// defines how circles change appearance and position in response to cursor drag\ndrag = {\n\n    // move the circles to cursor position when dragging is active\n    function dragged(event, d){\n        var newx = event.x;\n        if (newx &lt; xbounds[0]) newx = xbounds[0];\n        if (newx &gt; xbounds[1]) newx = xbounds[1];\n        var newy = event.y;\n        if (newy &lt; ybounds[0]) newy = ybounds[0];\n        if (newy &gt; ybounds[1]) newy = ybounds[1];\n        \n        if (d3.select(this).attr('id') == \"0\") {\n            mutable x1 = newx;\n            mutable y1 = newy;\n        }\n        if (d3.select(this).attr('id') == \"1\") {\n            mutable x2 = newx;\n            mutable y2 = newy;\n        }\n        \n        d3.select(this).raise().attr(\"cx\", d.x = newx).attr(\"cy\", d.y = newy);\n\n        var dt1 = 2*Math.sqrt(sat_z**2 + (mutable x1/width*pixel_width - sat_x)**2 + (mutable y1/width*pixel_width - sat_y)**2);\n        var dt2 = 2*Math.sqrt(sat_z**2 + (mutable x2/width*pixel_width - sat_x)**2 + (mutable y2/width*pixel_width - sat_y)**2);\n        var p1  =  dt1 / wavelength *2 *Math.PI;\n        var p2  =  dt2 / wavelength *2 *Math.PI;\n\n        d3.select(\"rect\").attr(\"fill-opacity\", 1-Math.abs(Math.cos((p1-p2)/2)));\n        //d3.select(\"text\").text(1-Math.abs(Math.cos((p1-p2)/2))).style(\"fill\",\"darkOrange\");\n    }\n\n    // map the d3 drag event functionality to these custom functions\n    return d3.drag()\n        .on(\"drag\", dragged)\n}\n\n\n\n\n\n\n\n\n\nCode\nmutable x1= 2*width/5;\nmutable y1= height/3;\nmutable x2= 3*width/5;\nmutable y2= 2*height/3;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstroke_width = 7;\nwidth = 700;\nheight = 500 + 2*stroke_width;\nradius = 25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nxbounds = [width/7 + radius + 1, 6*width/7 - radius - 1]\nybounds = [ radius + 1  + stroke_width, height - radius - 1 - stroke_width]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndistance = 4;\nNumPoints = 1000;\nwavelength = .5;\namplitude = 15;\nspeed = 10;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// display variables\nxscale_factor = 100;\n\n\n\n\n\n\n\n\n\nCode\nsat_x = -100000;\nsat_y = 100000;\nsat_z = 600000;\npixel_width = 3;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndistance_travelled_w1 = 2*Math.sqrt(sat_z**2 + (x1/width*pixel_width - sat_x)**2 + (y1/width*pixel_width - sat_y)**2);\ndistance_travelled_w2 = 2*Math.sqrt(sat_z**2 + (x2/width*pixel_width - sat_x)**2 + (y2/width*pixel_width - sat_y)**2);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nphase_w1 = distance_travelled_w1 / wavelength *2 *Math.PI;\nphase_w2 = distance_travelled_w2 / wavelength *2 *Math.PI;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwave1 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j*xscale_factor, amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w2)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwave2 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j*xscale_factor , amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w1)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwaveSum = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j*xscale_factor , amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w1) + amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w2)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\ntime = {\n  let i = 0;\n  while (true) {\n    i += speed * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\nr = d3.line()(wave1);\nb = d3.line()(wave2);\nsvg`&lt;svg viewBox=\"0 -32 400 64\"&gt;\n  &lt;path d=\"${r}\" stroke=\"red\" fill=\"none\" /&gt;\n  &lt;path d=\"${b}\" stroke=\"blue\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\np = d3.line()(waveSum);\nsvg`&lt;svg viewBox=\"0 -64 400 130\"&gt;\n  &lt;path d=\"${p}\" stroke=\"black\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nd3 = require(\"d3@7\")\n\n\n\n\n\n\n\nHere we’ve considered a SAR satellite 600km above Earth, emitting 50cm wavelength radiation with a pixel resolution of 3m.\nThe distance from each target to the satellite affects where in their cycle each wave is re-intercepted, and thus the difference determines whether those returned waves interfere constructively or deconstructively. Thus a random distribution of targets creates a random difference in distance to the satellite, creating a random level of interference in each pixel. This means the intensity of each pixel is randomly (though not necessarily uniformly) multiplied by a value from 0 (perfect deconstructive interference) to 1 (perfect constructive interference). This is the origin of speckle, and reason why it manifests as multiplicative noise (as opposed to additive)."
  },
  {
    "objectID": "teaching/teaching_landingpage.html",
    "href": "teaching/teaching_landingpage.html",
    "title": "Teaching",
    "section": "",
    "text": "Are you a student in my class? A colleague? Graduate student desperately searching the web for an explanation of an obscure concept? Here you’ll find a selection of teaching resources associated with my classes and workshops."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "jf_web",
    "section": "",
    "text": "Hi! I am still being built! Check out the incomplete notes below and check back in later -jf\nEverything on this website was built and programmed by me, some of it even in languages I understand! However, it would not have been possible without the immense body of literature and work made freely available by countless people all over the world. In that spirit, the entire code for this website is freely available here."
  },
  {
    "objectID": "index.html#speckle-as-a-wave-interference-phenomenon",
    "href": "index.html#speckle-as-a-wave-interference-phenomenon",
    "title": "jf_web",
    "section": "Speckle as a wave interference phenomenon",
    "text": "Speckle as a wave interference phenomenon\nLet’s look an illustrative real-world manifestation of this conceptual framework. SAR images are subject to speckle, a type of image distortion or noise which affects pixels in a stochastic, multiplicative way. Why does this occur?\nConsider that the returned wave associated with a given pixel likely isn’t the result of a single interation with a single pointwise object. If multiple reflectors (or similarly, a continuous reflector) lie within the pixel, then the returned wave is the sum of multiple individual waves.\nLet’s imagine we have a pixel with two identical point reflectors lying within it. How does the returned wave change as a function of where those reflectors are located? Move the blue and red targets in the pixel below:\n\n\n\n\nCode\nchart = {\n    const svg = d3.create(\"svg\").attr(\"viewBox\", [0, 0, width, height])\n\n    // define a bounding rectangle\n    svg.append(\"rect\")\n        .attr(\"x\", width/7)\n        .attr(\"y\", stroke_width)\n        .attr(\"width\", 5*width/7)\n        .attr(\"height\", height - 2*stroke_width)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-width\", stroke_width)\n        .attr(\"fill-opacity\", 0.087124976) //This is a hard-coded value based on the prescribed physical parameters. It's hardcoded because it's easier than dealing with the resulting reactive dependencies since this cell should never be run again\n\n    // define data used for circles\n    const circles = d3.range(2).map(i =&gt; ({\n        x: (i+2) * width / 5,\n        y: (i+1) * height / 3,\n        index: i, \n    }));\n\n    // define circles as graphic objects\n    svg.selectAll(\"circle\")\n        .data(circles)\n        .join(\"circle\")\n            .attr(\"cx\", d =&gt; d.x)\n            .attr(\"cy\", d =&gt; d.y)\n            .attr(\"r\", radius)\n            .attr(\"fill\", d =&gt; d3.schemeCategory10[d.index * 3])\n            .attr(\"id\", function(d,i) {return i})\n            .call(drag)\n\n    return svg.node();\n}\n\n\n\n\n\n\n\n\n\nCode\nchart2 = {\n    const svg = d3.create(\"svg\").attr(\"viewBox\", [0, 0, width, height])\n\n    //define a function to take the canvas position of the leftside chart to the\n    //  corresponding region in the second chart\n    //  it's messy because I solved the system by hand and didn't simplify, RIP\n    //  to future Jake if I ever have to un-hardcode the object position values\n    function lineartransform(xposition){\n        return (2*height/5 - radius)/(5/7*width -2*radius-2)*xposition + width/7 + 2/5*height + radius/2 - (2*height/5 - radius)*(width/7+radius+1)/(5/7*width-2*radius-2)\n    }\n\n    // define a earth curvature line\n    svg.append(\"rect\")\n        .attr(\"x\", width/7)\n        .attr(\"y\", height - 2*stroke_width)\n        .attr(\"width\", 5*width/7)\n        .attr(\"height\", stroke_width/2)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-width\", stroke_width)\n        .attr(\"fill-opacity\", 0)\n\n    // define lines going from the target to the satellites (first, so they appear under them)\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 3*height/20)\n        .attr(\"x2\", lineartransform(x1))\n        .attr(\"y1\", 3*height/20)\n        .attr(\"y2\", height - 2*stroke_width)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"blue\")\n\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 3*height/20)\n        .attr(\"x2\", lineartransform(x2))\n        .attr(\"y1\", 3*height/20)\n        .attr(\"y2\", height - 2*stroke_width)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"red\")\n\n\n    // define a rectangle representing the satellite\n    svg.append(\"rect\")\n        .attr(\"x\", width/7 + height/10)\n        .attr(\"y\", height/10)\n        .attr(\"width\", height/10)\n        .attr(\"height\", height/10)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-width\", stroke_width)\n        .attr(\"fill-opacity\", .50)\n    \n    // define notches indicating the bounds of the pixel\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 2*height/5)\n        .attr(\"x2\", width/7 + 2*height/5)\n        .attr(\"y1\", height - 2*stroke_width)\n        .attr(\"y2\", height - 2*stroke_width - height/20)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"black\")\n\n    svg.append(\"line\")\n        .attr(\"x1\", width/7 + 4*height/5)\n        .attr(\"x2\", width/7 + 4*height/5)\n        .attr(\"y1\", height - 2*stroke_width)\n        .attr(\"y2\", height - 2*stroke_width - height/20)\n        .style(\"stroke-width\", stroke_width)\n        .style(\"stroke\", \"black\")\n\n    // define data used for circles\n    const circles = d3.range(2).map(i =&gt; ({\n        x: (i+2) * width / 5,\n        y: (i+1) * height / 3,\n        index: i, \n    }));\n\n    // define circles as graphic objects\n    svg.selectAll(\"circle\")\n        .data(circles)\n        .join(\"circle\")\n            .attr(\"cx\", function(d,i) {\n                if (i == 0) {return lineartransform(x1)}\n                else {return lineartransform(x2)}\n            })\n            .attr(\"cy\", height - 2*stroke_width)\n            .attr(\"r\", radius/2)\n            .attr(\"fill\", d =&gt; d3.schemeCategory10[d.index * 3])\n            .attr(\"id\", function(d,i) {return i})\n\n    // add text\n    svg.append(\"text\")\n        .attr(\"x\", width/7)\n        .attr(\"y\", .94*height)\n        .style(\"font-size\", \"28px\")\n        .text(\"side view\")\n\n    svg.append(\"text\")\n        .attr(\"x\", width/2)\n        .attr(\"y\", .15*height)\n        .style(\"font-size\", \"24px\")\n        .style(\"font-style\", \"italic\")\n        .text(\"*wildly not to scale\")\n\n    return svg.node();\n}\n\n\n\n\n\n\n\n\n\n\n\nCode\nformatted_d1 = (0.5*distance_travelled_w1).toFixed(2).replace(/\\B(?&lt;!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, \",\");\nformatted_d2 = (0.5*distance_travelled_w2).toFixed(2).replace(/\\B(?&lt;!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, \",\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistance from target one to the satellite: m\nDistance from target two to the satellite: m\n\n\n\nCode\n// defines how circles change appearance and position in response to cursor drag\ndrag = {\n\n    // move the circles to cursor position when dragging is active\n    function dragged(event, d){\n        var newx = event.x;\n        if (newx &lt; xbounds[0]) newx = xbounds[0];\n        if (newx &gt; xbounds[1]) newx = xbounds[1];\n        var newy = event.y;\n        if (newy &lt; ybounds[0]) newy = ybounds[0];\n        if (newy &gt; ybounds[1]) newy = ybounds[1];\n        \n        if (d3.select(this).attr('id') == \"0\") {\n            mutable x1 = newx;\n            mutable y1 = newy;\n        }\n        if (d3.select(this).attr('id') == \"1\") {\n            mutable x2 = newx;\n            mutable y2 = newy;\n        }\n        \n        d3.select(this).raise().attr(\"cx\", d.x = newx).attr(\"cy\", d.y = newy);\n\n        var dt1 = 2*Math.sqrt(sat_z**2 + (mutable x1/width*pixel_width - sat_x)**2 + (mutable y1/width*pixel_width - sat_y)**2);\n        var dt2 = 2*Math.sqrt(sat_z**2 + (mutable x2/width*pixel_width - sat_x)**2 + (mutable y2/width*pixel_width - sat_y)**2);\n        var p1  =  dt1 / wavelength *2 *Math.PI;\n        var p2  =  dt2 / wavelength *2 *Math.PI;\n\n        d3.select(\"rect\").attr(\"fill-opacity\", 1-Math.abs(Math.cos((p1-p2)/2)));\n        //d3.select(\"text\").text(1-Math.abs(Math.cos((p1-p2)/2))).style(\"fill\",\"darkOrange\");\n    }\n\n    // map the d3 drag event functionality to these custom functions\n    return d3.drag()\n        .on(\"drag\", dragged)\n}\n\n\n\n\n\n\n\n\n\nCode\nmutable x1= 2*width/5;\nmutable y1= height/3;\nmutable x2= 3*width/5;\nmutable y2= 2*height/3;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstroke_width = 7;\nwidth = 700;\nheight = 500 + 2*stroke_width;\nradius = 25;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nxbounds = [width/7 + radius + 1, 6*width/7 - radius - 1]\nybounds = [ radius + 1  + stroke_width, height - radius - 1 - stroke_width]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndistance = 4;\nNumPoints = 1000;\nwavelength = .5;\namplitude = 15;\nspeed = 10;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// display variables\nxscale_factor = 100;\n\n\n\n\n\n\n\n\n\nCode\nsat_x = -100000;\nsat_y = 100000;\nsat_z = 600000;\npixel_width = 3;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndistance_travelled_w1 = 2*Math.sqrt(sat_z**2 + (x1/width*pixel_width - sat_x)**2 + (y1/width*pixel_width - sat_y)**2);\ndistance_travelled_w2 = 2*Math.sqrt(sat_z**2 + (x2/width*pixel_width - sat_x)**2 + (y2/width*pixel_width - sat_y)**2);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nphase_w1 = distance_travelled_w1 / wavelength *2 *Math.PI;\nphase_w2 = distance_travelled_w2 / wavelength *2 *Math.PI;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nwave1 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j*xscale_factor, amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w2)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwave2 = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j*xscale_factor , amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w1)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\nwaveSum = {\n    var data = [];\n    for (var i = 1; i &lt;= NumPoints; i++) {\n        var j = i * distance / NumPoints;\n        data.push([j*xscale_factor , amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w1) + amplitude * Math.sin(j * 2*Math.PI / wavelength + time + phase_w2)]);\n    }\n    return data;\n}\n\n\n\n\n\n\n\n\n\nCode\ntime = {\n  let i = 0;\n  while (true) {\n    i += speed * 0.01;\n    yield i\n  }\n}\n\n\n\n\n\n\n\n\n\nCode\nr = d3.line()(wave1);\nb = d3.line()(wave2);\nsvg`&lt;svg viewBox=\"0 -32 400 64\"&gt;\n  &lt;path d=\"${r}\" stroke=\"red\" fill=\"none\" /&gt;\n  &lt;path d=\"${b}\" stroke=\"blue\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\np = d3.line()(waveSum);\nsvg`&lt;svg viewBox=\"0 -64 400 130\"&gt;\n  &lt;path d=\"${p}\" stroke=\"black\" fill=\"none\" /&gt;\n&lt;/svg&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nd3 = require(\"d3@7\")\n\n\n\n\n\n\n\nHere we’ve considered a SAR satellite 600km above Earth, emitting 50cm wavelength radiation with a pixel resolution of 3m.\nThe distance from each target to the satellite affects where in their cycle each wave is re-intercepted, and thus the difference determines whether those returned waves interfere constructively or deconstructively. Thus a random distribution of targets creates a random difference in distance to the satellite, creating a random level of interference in each pixel. This means the intensity of each pixel is randomly (though not necessarily uniformly) multiplied by a value from 0 (perfect deconstructive interference) to 1 (perfect constructive interference). This is the origin of speckle, and reason why it manifests as multiplicative noise (as opposed to additive)."
  },
  {
    "objectID": "contact.html",
    "href": "contact.html",
    "title": "contact",
    "section": "",
    "text": "text text text"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "about",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "about_jake.html",
    "href": "about_jake.html",
    "title": "Jake Ferguson",
    "section": "",
    "text": "Code\nmx = d3.max(gridData, d=&gt;d.x);\nmy = d3.max(gridData, d=&gt;d.y);\nheight = 460;\nwidth  = 300;\nnumCellsx = 21;\nnumCellsy = 32;\n\ngridData = {\n    var da = [];\n    var c = 0;\n    for (var j = 0; j &lt;= numCellsx; j++) {\n        for (var k = 0; k &lt;= numCellsy; k++) {\n        c+=1;\n        da.push({id:c,x:j,y:k,opa:1});\n    }}\n    return da;\n}\n\n{\n\n  var hover  = -10;\n  var ref_x  = 0;\n  var ref_y  = 0;\n  var dist   = 0;\n  var stophover = false\n  const svg = d3.select(DOM.svg(width, height));\n\n\n  svg.append(\"image\")\n    .attr(\"width\", \"100%\")\n    .attr(\"height\", \"100%\")\n    .attr(\"xlink:href\", \"static/logo_think.png\");\n\n  var node = svg.selectAll(\"g.node\")\n    .data(gridData, d =&gt; d.id)\n    \n  var nodeEnter = node.enter()\n    .append(\"svg:g\")\n    .attr(\"class\", \"node\")\n\n  nodeEnter.append(\"rect\")\n    .attr(\"id\", d =&gt; d.id)\n    .attr(\"x\", d =&gt; scale_x(d.x))\n    .attr(\"y\", d =&gt; scale_y(d.y))\n    .attr(\"width\", width/(mx+1))\n    .attr(\"height\", height/(my+1))\n    .attr(\"fill\", \"white\")\n    .attr(\"opacity\", function(d){\n      if (d.x &gt; numCellsx/3 && d.x &lt; numCellsx*.75 && d.y &gt; numCellsy/10 && d.y &lt; numCellsy/4.5) {\n        d.opa = 0\n        return 0}\n      else {return 1}\n    })\n    .on(\"mouseover\", function (event, d) {\n      if (!stophover){\n      hover = d.id\n      ref_x = d.x\n      ref_y = d.y\n      d3.selectAll(\"rect\")\n        //.transition()\n        //.delay(function(d,i){return Math.sqrt(Math.abs(d.x - ref_x)**2 + Math.abs(d.y - ref_y)**2);})\n        //.duration(1000)\n        //.attr(\"opacity\",0)\n        .attr(\"opacity\",function(d){\n          if (Math.sqrt(Math.abs(d.x - ref_x)**2 + Math.abs(d.y - ref_y)**2) &lt; 4.1) {\n            d.opa = d.opa*.93\n            return d.opa*.93}\n          else {return d3.select(this).attr(\"opacity\")}\n        })}\n    })\n    .on(\"click\", function (event, d) {\n      stophover = true\n      hover = d.id\n      ref_x = d.x\n      ref_y = d.y\n      d3.selectAll(\"rect\")\n        .transition()\n        .delay(function(d,i){return 100*Math.sqrt(Math.abs(d.x - ref_x)**2 + Math.abs(d.y - ref_y)**2)})\n        .duration(1000)\n        .attr(\"opacity\",function(d){\n          d.opa = 0\n          return 0\n        })\n    });\n\n  return svg.node();\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nscale_x = d3.scaleLinear()\n  .domain([0, mx])\n  .range([0, width * (1-1/(mx+1))])\n\n\n\n\n\n\n\n\nCode\nscale_y = d3.scaleLinear()\n  .domain([0, my])\n  .range([0, height * (1-1/(my+1))])\n\n\n\n\n\n\n\nJake Ferguson\nJake (he/him) is a PhD Candidate in Geography and Environmental Management at the University of Waterloo. He’s interested in SAR Interferometry, SAR Polarimetry, producing open educational resources, and fussing over his website’s D3 renders.\nTo see an image of me, click here\n\n\n\nEducation\nUniversity of Waterloo | Waterloo, CA\nMSc. Physics, Computational Multiphysics Group | August 2019\nUniversity of Waterloo | Waterloo, CA\nBSc. Physics | April 2017\n\n\nSelect pubs\nPolarimetric decomposition of microwave-band freshwater ice SAR data: Review, analysis, and future directions"
  }
]